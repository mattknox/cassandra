#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'cassandra_types'

module Cassandra
  class Client
    include ::Thrift::Client

    def get_slice_by_name_range(tablename, key, columnParent, start, finish, count)
      send_get_slice_by_name_range(tablename, key, columnParent, start, finish, count)
      return recv_get_slice_by_name_range()
    end

    def send_get_slice_by_name_range(tablename, key, columnParent, start, finish, count)
      send_message('get_slice_by_name_range', Get_slice_by_name_range_args, :tablename => tablename, :key => key, :columnParent => columnParent, :start => start, :finish => finish, :count => count)
    end

    def recv_get_slice_by_name_range()
      result = receive_message(Get_slice_by_name_range_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_by_name_range failed: unknown result')
    end

    def get_slice_by_names(tablename, key, columnParent, columnNames)
      send_get_slice_by_names(tablename, key, columnParent, columnNames)
      return recv_get_slice_by_names()
    end

    def send_get_slice_by_names(tablename, key, columnParent, columnNames)
      send_message('get_slice_by_names', Get_slice_by_names_args, :tablename => tablename, :key => key, :columnParent => columnParent, :columnNames => columnNames)
    end

    def recv_get_slice_by_names()
      result = receive_message(Get_slice_by_names_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_by_names failed: unknown result')
    end

    def get_slice(tablename, key, columnParent, isAscending, count)
      send_get_slice(tablename, key, columnParent, isAscending, count)
      return recv_get_slice()
    end

    def send_get_slice(tablename, key, columnParent, isAscending, count)
      send_message('get_slice', Get_slice_args, :tablename => tablename, :key => key, :columnParent => columnParent, :isAscending => isAscending, :count => count)
    end

    def recv_get_slice()
      result = receive_message(Get_slice_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice failed: unknown result')
    end

    def get_column(tablename, key, columnPath)
      send_get_column(tablename, key, columnPath)
      return recv_get_column()
    end

    def send_get_column(tablename, key, columnPath)
      send_message('get_column', Get_column_args, :tablename => tablename, :key => key, :columnPath => columnPath)
    end

    def recv_get_column()
      result = receive_message(Get_column_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_column failed: unknown result')
    end

    def get_column_count(tablename, key, columnParent)
      send_get_column_count(tablename, key, columnParent)
      return recv_get_column_count()
    end

    def send_get_column_count(tablename, key, columnParent)
      send_message('get_column_count', Get_column_count_args, :tablename => tablename, :key => key, :columnParent => columnParent)
    end

    def recv_get_column_count()
      result = receive_message(Get_column_count_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_column_count failed: unknown result')
    end

    def insert(tablename, key, columnPath, cellData, timestamp, block_for)
      send_insert(tablename, key, columnPath, cellData, timestamp, block_for)
      recv_insert()
    end

    def send_insert(tablename, key, columnPath, cellData, timestamp, block_for)
      send_message('insert', Insert_args, :tablename => tablename, :key => key, :columnPath => columnPath, :cellData => cellData, :timestamp => timestamp, :block_for => block_for)
    end

    def recv_insert()
      result = receive_message(Insert_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def batch_insert(batchMutation, block_for)
      send_batch_insert(batchMutation, block_for)
      recv_batch_insert()
    end

    def send_batch_insert(batchMutation, block_for)
      send_message('batch_insert', Batch_insert_args, :batchMutation => batchMutation, :block_for => block_for)
    end

    def recv_batch_insert()
      result = receive_message(Batch_insert_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def remove(tablename, key, columnPathOrParent, timestamp, block_for)
      send_remove(tablename, key, columnPathOrParent, timestamp, block_for)
      recv_remove()
    end

    def send_remove(tablename, key, columnPathOrParent, timestamp, block_for)
      send_message('remove', Remove_args, :tablename => tablename, :key => key, :columnPathOrParent => columnPathOrParent, :timestamp => timestamp, :block_for => block_for)
    end

    def recv_remove()
      result = receive_message(Remove_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def get_columns_since(tablename, key, columnParent, timeStamp)
      send_get_columns_since(tablename, key, columnParent, timeStamp)
      return recv_get_columns_since()
    end

    def send_get_columns_since(tablename, key, columnParent, timeStamp)
      send_message('get_columns_since', Get_columns_since_args, :tablename => tablename, :key => key, :columnParent => columnParent, :timeStamp => timeStamp)
    end

    def recv_get_columns_since()
      result = receive_message(Get_columns_since_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_columns_since failed: unknown result')
    end

    def get_slice_super(tablename, key, columnFamily, isAscending, count)
      send_get_slice_super(tablename, key, columnFamily, isAscending, count)
      return recv_get_slice_super()
    end

    def send_get_slice_super(tablename, key, columnFamily, isAscending, count)
      send_message('get_slice_super', Get_slice_super_args, :tablename => tablename, :key => key, :columnFamily => columnFamily, :isAscending => isAscending, :count => count)
    end

    def recv_get_slice_super()
      result = receive_message(Get_slice_super_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_super failed: unknown result')
    end

    def get_slice_super_by_names(tablename, key, columnFamily, superColumnNames)
      send_get_slice_super_by_names(tablename, key, columnFamily, superColumnNames)
      return recv_get_slice_super_by_names()
    end

    def send_get_slice_super_by_names(tablename, key, columnFamily, superColumnNames)
      send_message('get_slice_super_by_names', Get_slice_super_by_names_args, :tablename => tablename, :key => key, :columnFamily => columnFamily, :superColumnNames => superColumnNames)
    end

    def recv_get_slice_super_by_names()
      result = receive_message(Get_slice_super_by_names_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_super_by_names failed: unknown result')
    end

    def get_superColumn(tablename, key, superColumnPath)
      send_get_superColumn(tablename, key, superColumnPath)
      return recv_get_superColumn()
    end

    def send_get_superColumn(tablename, key, superColumnPath)
      send_message('get_superColumn', Get_superColumn_args, :tablename => tablename, :key => key, :superColumnPath => superColumnPath)
    end

    def recv_get_superColumn()
      result = receive_message(Get_superColumn_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_superColumn failed: unknown result')
    end

    def batch_insert_superColumn(batchMutationSuper, block_for)
      send_batch_insert_superColumn(batchMutationSuper, block_for)
      recv_batch_insert_superColumn()
    end

    def send_batch_insert_superColumn(batchMutationSuper, block_for)
      send_message('batch_insert_superColumn', Batch_insert_superColumn_args, :batchMutationSuper => batchMutationSuper, :block_for => block_for)
    end

    def recv_batch_insert_superColumn()
      result = receive_message(Batch_insert_superColumn_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def get_key_range(tablename, columnFamilies, startWith, stopAt, maxResults)
      send_get_key_range(tablename, columnFamilies, startWith, stopAt, maxResults)
      return recv_get_key_range()
    end

    def send_get_key_range(tablename, columnFamilies, startWith, stopAt, maxResults)
      send_message('get_key_range', Get_key_range_args, :tablename => tablename, :columnFamilies => columnFamilies, :startWith => startWith, :stopAt => stopAt, :maxResults => maxResults)
    end

    def recv_get_key_range()
      result = receive_message(Get_key_range_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_key_range failed: unknown result')
    end

    def getStringProperty(propertyName)
      send_getStringProperty(propertyName)
      return recv_getStringProperty()
    end

    def send_getStringProperty(propertyName)
      send_message('getStringProperty', GetStringProperty_args, :propertyName => propertyName)
    end

    def recv_getStringProperty()
      result = receive_message(GetStringProperty_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getStringProperty failed: unknown result')
    end

    def getStringListProperty(propertyName)
      send_getStringListProperty(propertyName)
      return recv_getStringListProperty()
    end

    def send_getStringListProperty(propertyName)
      send_message('getStringListProperty', GetStringListProperty_args, :propertyName => propertyName)
    end

    def recv_getStringListProperty()
      result = receive_message(GetStringListProperty_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getStringListProperty failed: unknown result')
    end

    def describeTable(tableName)
      send_describeTable(tableName)
      return recv_describeTable()
    end

    def send_describeTable(tableName)
      send_message('describeTable', DescribeTable_args, :tableName => tableName)
    end

    def recv_describeTable()
      result = receive_message(DescribeTable_result)
      return result.success unless result.success.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'describeTable failed: unknown result')
    end

    def executeQuery(query)
      send_executeQuery(query)
      return recv_executeQuery()
    end

    def send_executeQuery(query)
      send_message('executeQuery', ExecuteQuery_args, :query => query)
    end

    def recv_executeQuery()
      result = receive_message(ExecuteQuery_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'executeQuery failed: unknown result')
    end

  end

  class Processor
    include ::Thrift::Processor

    def process_get_slice_by_name_range(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_by_name_range_args)
      result = Get_slice_by_name_range_result.new()
      begin
        result.success = @handler.get_slice_by_name_range(args.tablename, args.key, args.columnParent, args.start, args.finish, args.count)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_slice_by_name_range', seqid)
    end

    def process_get_slice_by_names(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_by_names_args)
      result = Get_slice_by_names_result.new()
      begin
        result.success = @handler.get_slice_by_names(args.tablename, args.key, args.columnParent, args.columnNames)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_slice_by_names', seqid)
    end

    def process_get_slice(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_args)
      result = Get_slice_result.new()
      begin
        result.success = @handler.get_slice(args.tablename, args.key, args.columnParent, args.isAscending, args.count)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_slice', seqid)
    end

    def process_get_column(seqid, iprot, oprot)
      args = read_args(iprot, Get_column_args)
      result = Get_column_result.new()
      begin
        result.success = @handler.get_column(args.tablename, args.key, args.columnPath)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_column', seqid)
    end

    def process_get_column_count(seqid, iprot, oprot)
      args = read_args(iprot, Get_column_count_args)
      result = Get_column_count_result.new()
      begin
        result.success = @handler.get_column_count(args.tablename, args.key, args.columnParent)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_column_count', seqid)
    end

    def process_insert(seqid, iprot, oprot)
      args = read_args(iprot, Insert_args)
      result = Insert_result.new()
      begin
        @handler.insert(args.tablename, args.key, args.columnPath, args.cellData, args.timestamp, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'insert', seqid)
    end

    def process_batch_insert(seqid, iprot, oprot)
      args = read_args(iprot, Batch_insert_args)
      result = Batch_insert_result.new()
      begin
        @handler.batch_insert(args.batchMutation, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'batch_insert', seqid)
    end

    def process_remove(seqid, iprot, oprot)
      args = read_args(iprot, Remove_args)
      result = Remove_result.new()
      begin
        @handler.remove(args.tablename, args.key, args.columnPathOrParent, args.timestamp, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'remove', seqid)
    end

    def process_get_columns_since(seqid, iprot, oprot)
      args = read_args(iprot, Get_columns_since_args)
      result = Get_columns_since_result.new()
      begin
        result.success = @handler.get_columns_since(args.tablename, args.key, args.columnParent, args.timeStamp)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_columns_since', seqid)
    end

    def process_get_slice_super(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_super_args)
      result = Get_slice_super_result.new()
      begin
        result.success = @handler.get_slice_super(args.tablename, args.key, args.columnFamily, args.isAscending, args.count)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_slice_super', seqid)
    end

    def process_get_slice_super_by_names(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_super_by_names_args)
      result = Get_slice_super_by_names_result.new()
      begin
        result.success = @handler.get_slice_super_by_names(args.tablename, args.key, args.columnFamily, args.superColumnNames)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_slice_super_by_names', seqid)
    end

    def process_get_superColumn(seqid, iprot, oprot)
      args = read_args(iprot, Get_superColumn_args)
      result = Get_superColumn_result.new()
      begin
        result.success = @handler.get_superColumn(args.tablename, args.key, args.superColumnPath)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_superColumn', seqid)
    end

    def process_batch_insert_superColumn(seqid, iprot, oprot)
      args = read_args(iprot, Batch_insert_superColumn_args)
      result = Batch_insert_superColumn_result.new()
      begin
        @handler.batch_insert_superColumn(args.batchMutationSuper, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'batch_insert_superColumn', seqid)
    end

    def process_get_key_range(seqid, iprot, oprot)
      args = read_args(iprot, Get_key_range_args)
      result = Get_key_range_result.new()
      begin
        result.success = @handler.get_key_range(args.tablename, args.columnFamilies, args.startWith, args.stopAt, args.maxResults)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_key_range', seqid)
    end

    def process_getStringProperty(seqid, iprot, oprot)
      args = read_args(iprot, GetStringProperty_args)
      result = GetStringProperty_result.new()
      result.success = @handler.getStringProperty(args.propertyName)
      write_result(result, oprot, 'getStringProperty', seqid)
    end

    def process_getStringListProperty(seqid, iprot, oprot)
      args = read_args(iprot, GetStringListProperty_args)
      result = GetStringListProperty_result.new()
      result.success = @handler.getStringListProperty(args.propertyName)
      write_result(result, oprot, 'getStringListProperty', seqid)
    end

    def process_describeTable(seqid, iprot, oprot)
      args = read_args(iprot, DescribeTable_args)
      result = DescribeTable_result.new()
      begin
        result.success = @handler.describeTable(args.tableName)
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'describeTable', seqid)
    end

    def process_executeQuery(seqid, iprot, oprot)
      args = read_args(iprot, ExecuteQuery_args)
      result = ExecuteQuery_result.new()
      result.success = @handler.executeQuery(args.query)
      write_result(result, oprot, 'executeQuery', seqid)
    end

  end

  # HELPER FUNCTIONS AND STRUCTURES

  class Get_slice_by_name_range_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPARENT = 3
    START = 4
    FINISH = 5
    COUNT = 6

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnParent, :start, :finish, :count
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnParent'},
      START => {:type => ::Thrift::Types::STRING, :name => 'start'},
      FINISH => {:type => ::Thrift::Types::STRING, :name => 'finish'},
      COUNT => {:type => ::Thrift::Types::I32, :name => 'count', :default => -1}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_by_name_range_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_by_names_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPARENT = 3
    COLUMNNAMES = 4

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnParent, :columnNames
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnParent'},
      COLUMNNAMES => {:type => ::Thrift::Types::LIST, :name => 'columnNames', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_by_names_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPARENT = 3
    ISASCENDING = 4
    COUNT = 5

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnParent, :isAscending, :count
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnParent'},
      ISASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'isAscending'},
      COUNT => {:type => ::Thrift::Types::I32, :name => 'count'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPATH = 3

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnPath
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPATH => {:type => ::Thrift::Types::STRING, :name => 'columnPath'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => Column_t},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_count_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPARENT = 3

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnParent
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnParent'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_count_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Insert_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPATH = 3
    CELLDATA = 4
    TIMESTAMP = 5
    BLOCK_FOR = 6

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnPath, :cellData, :timestamp, :block_for
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPATH => {:type => ::Thrift::Types::STRING, :name => 'columnPath'},
      CELLDATA => {:type => ::Thrift::Types::STRING, :name => 'cellData'},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Insert_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_args
    include ::Thrift::Struct
    BATCHMUTATION = 1
    BLOCK_FOR = 2

    ::Thrift::Struct.field_accessor self, :batchMutation, :block_for
    FIELDS = {
      BATCHMUTATION => {:type => ::Thrift::Types::STRUCT, :name => 'batchMutation', :class => Batch_mutation_t},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Remove_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPATHORPARENT = 3
    TIMESTAMP = 4
    BLOCK_FOR = 5

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnPathOrParent, :timestamp, :block_for
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPATHORPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnPathOrParent'},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Remove_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_columns_since_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNPARENT = 3
    TIMESTAMP = 4

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnParent, :timeStamp
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNPARENT => {:type => ::Thrift::Types::STRING, :name => 'columnParent'},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timeStamp'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_columns_since_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNFAMILY = 3
    ISASCENDING = 4
    COUNT = 5

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnFamily, :isAscending, :count
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNFAMILY => {:type => ::Thrift::Types::STRING, :name => 'columnFamily'},
      ISASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'isAscending'},
      COUNT => {:type => ::Thrift::Types::I32, :name => 'count'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => SuperColumn_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_by_names_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    COLUMNFAMILY = 3
    SUPERCOLUMNNAMES = 4

    ::Thrift::Struct.field_accessor self, :tablename, :key, :columnFamily, :superColumnNames
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMNFAMILY => {:type => ::Thrift::Types::STRING, :name => 'columnFamily'},
      SUPERCOLUMNNAMES => {:type => ::Thrift::Types::LIST, :name => 'superColumnNames', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_by_names_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => SuperColumn_t}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_superColumn_args
    include ::Thrift::Struct
    TABLENAME = 1
    KEY = 2
    SUPERCOLUMNPATH = 3

    ::Thrift::Struct.field_accessor self, :tablename, :key, :superColumnPath
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      SUPERCOLUMNPATH => {:type => ::Thrift::Types::STRING, :name => 'superColumnPath'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_superColumn_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => SuperColumn_t},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_superColumn_args
    include ::Thrift::Struct
    BATCHMUTATIONSUPER = 1
    BLOCK_FOR = 2

    ::Thrift::Struct.field_accessor self, :batchMutationSuper, :block_for
    FIELDS = {
      BATCHMUTATIONSUPER => {:type => ::Thrift::Types::STRUCT, :name => 'batchMutationSuper', :class => Batch_mutation_super_t},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_superColumn_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_key_range_args
    include ::Thrift::Struct
    TABLENAME = 1
    COLUMNFAMILIES = 2
    STARTWITH = 3
    STOPAT = 4
    MAXRESULTS = 5

    ::Thrift::Struct.field_accessor self, :tablename, :columnFamilies, :startWith, :stopAt, :maxResults
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tablename'},
      COLUMNFAMILIES => {:type => ::Thrift::Types::LIST, :name => 'columnFamilies', :default => [
      ], :element => {:type => ::Thrift::Types::STRING}},
      STARTWITH => {:type => ::Thrift::Types::STRING, :name => 'startWith', :default => %q""},
      STOPAT => {:type => ::Thrift::Types::STRING, :name => 'stopAt', :default => %q""},
      MAXRESULTS => {:type => ::Thrift::Types::I32, :name => 'maxResults', :default => 1000}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_key_range_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringProperty_args
    include ::Thrift::Struct
    PROPERTYNAME = 1

    ::Thrift::Struct.field_accessor self, :propertyName
    FIELDS = {
      PROPERTYNAME => {:type => ::Thrift::Types::STRING, :name => 'propertyName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringProperty_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRING, :name => 'success'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringListProperty_args
    include ::Thrift::Struct
    PROPERTYNAME = 1

    ::Thrift::Struct.field_accessor self, :propertyName
    FIELDS = {
      PROPERTYNAME => {:type => ::Thrift::Types::STRING, :name => 'propertyName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringListProperty_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class DescribeTable_args
    include ::Thrift::Struct
    TABLENAME = 1

    ::Thrift::Struct.field_accessor self, :tableName
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class DescribeTable_result
    include ::Thrift::Struct
    SUCCESS = 0
    NFE = 1

    ::Thrift::Struct.field_accessor self, :success, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class ExecuteQuery_args
    include ::Thrift::Struct
    QUERY = 1

    ::Thrift::Struct.field_accessor self, :query
    FIELDS = {
      QUERY => {:type => ::Thrift::Types::STRING, :name => 'query'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class ExecuteQuery_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => CqlResult_t}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

end

