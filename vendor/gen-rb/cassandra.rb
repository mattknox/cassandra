#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'cassandra_types'

module Cassandra
  class Client
    include ::Thrift::Client

    def get_slice_by_names(table, key, column_parent, column_names)
      send_get_slice_by_names(table, key, column_parent, column_names)
      return recv_get_slice_by_names()
    end

    def send_get_slice_by_names(table, key, column_parent, column_names)
      send_message('get_slice_by_names', Get_slice_by_names_args, :table => table, :key => key, :column_parent => column_parent, :column_names => column_names)
    end

    def recv_get_slice_by_names()
      result = receive_message(Get_slice_by_names_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_by_names failed: unknown result')
    end

    def get_slice(table, key, column_parent, start, finish, is_ascending, count)
      send_get_slice(table, key, column_parent, start, finish, is_ascending, count)
      return recv_get_slice()
    end

    def send_get_slice(table, key, column_parent, start, finish, is_ascending, count)
      send_message('get_slice', Get_slice_args, :table => table, :key => key, :column_parent => column_parent, :start => start, :finish => finish, :is_ascending => is_ascending, :count => count)
    end

    def recv_get_slice()
      result = receive_message(Get_slice_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice failed: unknown result')
    end

    def get_column(table, key, column_path)
      send_get_column(table, key, column_path)
      return recv_get_column()
    end

    def send_get_column(table, key, column_path)
      send_message('get_column', Get_column_args, :table => table, :key => key, :column_path => column_path)
    end

    def recv_get_column()
      result = receive_message(Get_column_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_column failed: unknown result')
    end

    def get_column_count(table, key, column_parent)
      send_get_column_count(table, key, column_parent)
      return recv_get_column_count()
    end

    def send_get_column_count(table, key, column_parent)
      send_message('get_column_count', Get_column_count_args, :table => table, :key => key, :column_parent => column_parent)
    end

    def recv_get_column_count()
      result = receive_message(Get_column_count_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_column_count failed: unknown result')
    end

    def insert(table, key, column_path, value, timestamp, block_for)
      send_insert(table, key, column_path, value, timestamp, block_for)
      recv_insert()
    end

    def send_insert(table, key, column_path, value, timestamp, block_for)
      send_message('insert', Insert_args, :table => table, :key => key, :column_path => column_path, :value => value, :timestamp => timestamp, :block_for => block_for)
    end

    def recv_insert()
      result = receive_message(Insert_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def batch_insert(table, batch_mutation, block_for)
      send_batch_insert(table, batch_mutation, block_for)
      recv_batch_insert()
    end

    def send_batch_insert(table, batch_mutation, block_for)
      send_message('batch_insert', Batch_insert_args, :table => table, :batch_mutation => batch_mutation, :block_for => block_for)
    end

    def recv_batch_insert()
      result = receive_message(Batch_insert_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def remove(table, key, column_path_or_parent, timestamp, block_for)
      send_remove(table, key, column_path_or_parent, timestamp, block_for)
      recv_remove()
    end

    def send_remove(table, key, column_path_or_parent, timestamp, block_for)
      send_message('remove', Remove_args, :table => table, :key => key, :column_path_or_parent => column_path_or_parent, :timestamp => timestamp, :block_for => block_for)
    end

    def recv_remove()
      result = receive_message(Remove_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def get_columns_since(table, key, column_parent, timeStamp)
      send_get_columns_since(table, key, column_parent, timeStamp)
      return recv_get_columns_since()
    end

    def send_get_columns_since(table, key, column_parent, timeStamp)
      send_message('get_columns_since', Get_columns_since_args, :table => table, :key => key, :column_parent => column_parent, :timeStamp => timeStamp)
    end

    def recv_get_columns_since()
      result = receive_message(Get_columns_since_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_columns_since failed: unknown result')
    end

    def get_slice_super(table, key, column_family, start, finish, is_ascending, count)
      send_get_slice_super(table, key, column_family, start, finish, is_ascending, count)
      return recv_get_slice_super()
    end

    def send_get_slice_super(table, key, column_family, start, finish, is_ascending, count)
      send_message('get_slice_super', Get_slice_super_args, :table => table, :key => key, :column_family => column_family, :start => start, :finish => finish, :is_ascending => is_ascending, :count => count)
    end

    def recv_get_slice_super()
      result = receive_message(Get_slice_super_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_super failed: unknown result')
    end

    def get_slice_super_by_names(table, key, column_family, super_column_names)
      send_get_slice_super_by_names(table, key, column_family, super_column_names)
      return recv_get_slice_super_by_names()
    end

    def send_get_slice_super_by_names(table, key, column_family, super_column_names)
      send_message('get_slice_super_by_names', Get_slice_super_by_names_args, :table => table, :key => key, :column_family => column_family, :super_column_names => super_column_names)
    end

    def recv_get_slice_super_by_names()
      result = receive_message(Get_slice_super_by_names_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_slice_super_by_names failed: unknown result')
    end

    def get_super_column(table, key, super_column_path)
      send_get_super_column(table, key, super_column_path)
      return recv_get_super_column()
    end

    def send_get_super_column(table, key, super_column_path)
      send_message('get_super_column', Get_super_column_args, :table => table, :key => key, :super_column_path => super_column_path)
    end

    def recv_get_super_column()
      result = receive_message(Get_super_column_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_super_column failed: unknown result')
    end

    def batch_insert_super_column(table, batch_mutation_super, block_for)
      send_batch_insert_super_column(table, batch_mutation_super, block_for)
      recv_batch_insert_super_column()
    end

    def send_batch_insert_super_column(table, batch_mutation_super, block_for)
      send_message('batch_insert_super_column', Batch_insert_super_column_args, :table => table, :batch_mutation_super => batch_mutation_super, :block_for => block_for)
    end

    def recv_batch_insert_super_column()
      result = receive_message(Batch_insert_super_column_result)
      raise result.ire unless result.ire.nil?
      raise result.ue unless result.ue.nil?
      return
    end

    def get_key_range(table, column_family, startWith, stopAt, maxResults)
      send_get_key_range(table, column_family, startWith, stopAt, maxResults)
      return recv_get_key_range()
    end

    def send_get_key_range(table, column_family, startWith, stopAt, maxResults)
      send_message('get_key_range', Get_key_range_args, :table => table, :column_family => column_family, :startWith => startWith, :stopAt => stopAt, :maxResults => maxResults)
    end

    def recv_get_key_range()
      result = receive_message(Get_key_range_result)
      return result.success unless result.success.nil?
      raise result.ire unless result.ire.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get_key_range failed: unknown result')
    end

    def getStringProperty(propertyName)
      send_getStringProperty(propertyName)
      return recv_getStringProperty()
    end

    def send_getStringProperty(propertyName)
      send_message('getStringProperty', GetStringProperty_args, :propertyName => propertyName)
    end

    def recv_getStringProperty()
      result = receive_message(GetStringProperty_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getStringProperty failed: unknown result')
    end

    def getStringListProperty(propertyName)
      send_getStringListProperty(propertyName)
      return recv_getStringListProperty()
    end

    def send_getStringListProperty(propertyName)
      send_message('getStringListProperty', GetStringListProperty_args, :propertyName => propertyName)
    end

    def recv_getStringListProperty()
      result = receive_message(GetStringListProperty_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getStringListProperty failed: unknown result')
    end

    def describeTable(tableName)
      send_describeTable(tableName)
      return recv_describeTable()
    end

    def send_describeTable(tableName)
      send_message('describeTable', DescribeTable_args, :tableName => tableName)
    end

    def recv_describeTable()
      result = receive_message(DescribeTable_result)
      return result.success unless result.success.nil?
      raise result.nfe unless result.nfe.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'describeTable failed: unknown result')
    end

    def executeQuery(query)
      send_executeQuery(query)
      return recv_executeQuery()
    end

    def send_executeQuery(query)
      send_message('executeQuery', ExecuteQuery_args, :query => query)
    end

    def recv_executeQuery()
      result = receive_message(ExecuteQuery_result)
      return result.success unless result.success.nil?
      raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'executeQuery failed: unknown result')
    end

  end

  class Processor
    include ::Thrift::Processor

    def process_get_slice_by_names(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_by_names_args)
      result = Get_slice_by_names_result.new()
      begin
        result.success = @handler.get_slice_by_names(args.table, args.key, args.column_parent, args.column_names)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_slice_by_names', seqid)
    end

    def process_get_slice(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_args)
      result = Get_slice_result.new()
      begin
        result.success = @handler.get_slice(args.table, args.key, args.column_parent, args.start, args.finish, args.is_ascending, args.count)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_slice', seqid)
    end

    def process_get_column(seqid, iprot, oprot)
      args = read_args(iprot, Get_column_args)
      result = Get_column_result.new()
      begin
        result.success = @handler.get_column(args.table, args.key, args.column_path)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_column', seqid)
    end

    def process_get_column_count(seqid, iprot, oprot)
      args = read_args(iprot, Get_column_count_args)
      result = Get_column_count_result.new()
      begin
        result.success = @handler.get_column_count(args.table, args.key, args.column_parent)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_column_count', seqid)
    end

    def process_insert(seqid, iprot, oprot)
      args = read_args(iprot, Insert_args)
      result = Insert_result.new()
      begin
        @handler.insert(args.table, args.key, args.column_path, args.value, args.timestamp, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'insert', seqid)
    end

    def process_batch_insert(seqid, iprot, oprot)
      args = read_args(iprot, Batch_insert_args)
      result = Batch_insert_result.new()
      begin
        @handler.batch_insert(args.table, args.batch_mutation, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'batch_insert', seqid)
    end

    def process_remove(seqid, iprot, oprot)
      args = read_args(iprot, Remove_args)
      result = Remove_result.new()
      begin
        @handler.remove(args.table, args.key, args.column_path_or_parent, args.timestamp, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'remove', seqid)
    end

    def process_get_columns_since(seqid, iprot, oprot)
      args = read_args(iprot, Get_columns_since_args)
      result = Get_columns_since_result.new()
      begin
        result.success = @handler.get_columns_since(args.table, args.key, args.column_parent, args.timeStamp)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_columns_since', seqid)
    end

    def process_get_slice_super(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_super_args)
      result = Get_slice_super_result.new()
      begin
        result.success = @handler.get_slice_super(args.table, args.key, args.column_family, args.start, args.finish, args.is_ascending, args.count)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_slice_super', seqid)
    end

    def process_get_slice_super_by_names(seqid, iprot, oprot)
      args = read_args(iprot, Get_slice_super_by_names_args)
      result = Get_slice_super_by_names_result.new()
      begin
        result.success = @handler.get_slice_super_by_names(args.table, args.key, args.column_family, args.super_column_names)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_slice_super_by_names', seqid)
    end

    def process_get_super_column(seqid, iprot, oprot)
      args = read_args(iprot, Get_super_column_args)
      result = Get_super_column_result.new()
      begin
        result.success = @handler.get_super_column(args.table, args.key, args.super_column_path)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'get_super_column', seqid)
    end

    def process_batch_insert_super_column(seqid, iprot, oprot)
      args = read_args(iprot, Batch_insert_super_column_args)
      result = Batch_insert_super_column_result.new()
      begin
        @handler.batch_insert_super_column(args.table, args.batch_mutation_super, args.block_for)
      rescue InvalidRequestException => ire
        result.ire = ire
      rescue UnavailableException => ue
        result.ue = ue
      end
      write_result(result, oprot, 'batch_insert_super_column', seqid)
    end

    def process_get_key_range(seqid, iprot, oprot)
      args = read_args(iprot, Get_key_range_args)
      result = Get_key_range_result.new()
      begin
        result.success = @handler.get_key_range(args.table, args.column_family, args.startWith, args.stopAt, args.maxResults)
      rescue InvalidRequestException => ire
        result.ire = ire
      end
      write_result(result, oprot, 'get_key_range', seqid)
    end

    def process_getStringProperty(seqid, iprot, oprot)
      args = read_args(iprot, GetStringProperty_args)
      result = GetStringProperty_result.new()
      result.success = @handler.getStringProperty(args.propertyName)
      write_result(result, oprot, 'getStringProperty', seqid)
    end

    def process_getStringListProperty(seqid, iprot, oprot)
      args = read_args(iprot, GetStringListProperty_args)
      result = GetStringListProperty_result.new()
      result.success = @handler.getStringListProperty(args.propertyName)
      write_result(result, oprot, 'getStringListProperty', seqid)
    end

    def process_describeTable(seqid, iprot, oprot)
      args = read_args(iprot, DescribeTable_args)
      result = DescribeTable_result.new()
      begin
        result.success = @handler.describeTable(args.tableName)
      rescue NotFoundException => nfe
        result.nfe = nfe
      end
      write_result(result, oprot, 'describeTable', seqid)
    end

    def process_executeQuery(seqid, iprot, oprot)
      args = read_args(iprot, ExecuteQuery_args)
      result = ExecuteQuery_result.new()
      result.success = @handler.executeQuery(args.query)
      write_result(result, oprot, 'executeQuery', seqid)
    end

  end

  # HELPER FUNCTIONS AND STRUCTURES

  class Get_slice_by_names_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PARENT = 3
    COLUMN_NAMES = 4

    ::Thrift::Struct.field_accessor self, :table, :key, :column_parent, :column_names
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PARENT => {:type => ::Thrift::Types::STRUCT, :name => 'column_parent', :class => ColumnParent},
      COLUMN_NAMES => {:type => ::Thrift::Types::LIST, :name => 'column_names', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_by_names_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PARENT = 3
    START = 4
    FINISH = 5
    IS_ASCENDING = 6
    COUNT = 7

    ::Thrift::Struct.field_accessor self, :table, :key, :column_parent, :start, :finish, :is_ascending, :count
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PARENT => {:type => ::Thrift::Types::STRUCT, :name => 'column_parent', :class => ColumnParent},
      START => {:type => ::Thrift::Types::STRING, :name => 'start'},
      FINISH => {:type => ::Thrift::Types::STRING, :name => 'finish'},
      IS_ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'is_ascending'},
      COUNT => {:type => ::Thrift::Types::I32, :name => 'count', :default => 100}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PATH = 3

    ::Thrift::Struct.field_accessor self, :table, :key, :column_path
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PATH => {:type => ::Thrift::Types::STRUCT, :name => 'column_path', :class => ColumnPath}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => Column},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_count_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PARENT = 3

    ::Thrift::Struct.field_accessor self, :table, :key, :column_parent
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PARENT => {:type => ::Thrift::Types::STRUCT, :name => 'column_parent', :class => ColumnParent}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_column_count_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Insert_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PATH = 3
    VALUE = 4
    TIMESTAMP = 5
    BLOCK_FOR = 6

    ::Thrift::Struct.field_accessor self, :table, :key, :column_path, :value, :timestamp, :block_for
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PATH => {:type => ::Thrift::Types::STRUCT, :name => 'column_path', :class => ColumnPath},
      VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Insert_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_args
    include ::Thrift::Struct
    TABLE = 1
    BATCH_MUTATION = 2
    BLOCK_FOR = 3

    ::Thrift::Struct.field_accessor self, :table, :batch_mutation, :block_for
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      BATCH_MUTATION => {:type => ::Thrift::Types::STRUCT, :name => 'batch_mutation', :class => BatchMutation},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Remove_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PATH_OR_PARENT = 3
    TIMESTAMP = 4
    BLOCK_FOR = 5

    ::Thrift::Struct.field_accessor self, :table, :key, :column_path_or_parent, :timestamp, :block_for
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PATH_OR_PARENT => {:type => ::Thrift::Types::STRUCT, :name => 'column_path_or_parent', :class => ColumnPathOrParent},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Remove_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_columns_since_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_PARENT = 3
    TIMESTAMP = 4

    ::Thrift::Struct.field_accessor self, :table, :key, :column_parent, :timeStamp
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_PARENT => {:type => ::Thrift::Types::STRUCT, :name => 'column_parent', :class => ColumnParent},
      TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timeStamp'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_columns_since_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => Column}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_FAMILY = 3
    START = 4
    FINISH = 5
    IS_ASCENDING = 6
    COUNT = 7

    ::Thrift::Struct.field_accessor self, :table, :key, :column_family, :start, :finish, :is_ascending, :count
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_FAMILY => {:type => ::Thrift::Types::STRING, :name => 'column_family'},
      START => {:type => ::Thrift::Types::STRING, :name => 'start'},
      FINISH => {:type => ::Thrift::Types::STRING, :name => 'finish'},
      IS_ASCENDING => {:type => ::Thrift::Types::BOOL, :name => 'is_ascending'},
      COUNT => {:type => ::Thrift::Types::I32, :name => 'count', :default => 100}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => SuperColumn}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_by_names_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    COLUMN_FAMILY = 3
    SUPER_COLUMN_NAMES = 4

    ::Thrift::Struct.field_accessor self, :table, :key, :column_family, :super_column_names
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      COLUMN_FAMILY => {:type => ::Thrift::Types::STRING, :name => 'column_family'},
      SUPER_COLUMN_NAMES => {:type => ::Thrift::Types::LIST, :name => 'super_column_names', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_slice_super_by_names_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => SuperColumn}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_super_column_args
    include ::Thrift::Struct
    TABLE = 1
    KEY = 2
    SUPER_COLUMN_PATH = 3

    ::Thrift::Struct.field_accessor self, :table, :key, :super_column_path
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
      SUPER_COLUMN_PATH => {:type => ::Thrift::Types::STRUCT, :name => 'super_column_path', :class => SuperColumnPath}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_super_column_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1
    NFE = 2

    ::Thrift::Struct.field_accessor self, :success, :ire, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => SuperColumn},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_super_column_args
    include ::Thrift::Struct
    TABLE = 1
    BATCH_MUTATION_SUPER = 2
    BLOCK_FOR = 3

    ::Thrift::Struct.field_accessor self, :table, :batch_mutation_super, :block_for
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      BATCH_MUTATION_SUPER => {:type => ::Thrift::Types::STRUCT, :name => 'batch_mutation_super', :class => BatchMutationSuper},
      BLOCK_FOR => {:type => ::Thrift::Types::I32, :name => 'block_for', :default => 0}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Batch_insert_super_column_result
    include ::Thrift::Struct
    IRE = 1
    UE = 2

    ::Thrift::Struct.field_accessor self, :ire, :ue
    FIELDS = {
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException},
      UE => {:type => ::Thrift::Types::STRUCT, :name => 'ue', :class => UnavailableException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_key_range_args
    include ::Thrift::Struct
    TABLE = 1
    COLUMN_FAMILY = 2
    STARTWITH = 3
    STOPAT = 4
    MAXRESULTS = 5

    ::Thrift::Struct.field_accessor self, :table, :column_family, :startWith, :stopAt, :maxResults
    FIELDS = {
      TABLE => {:type => ::Thrift::Types::STRING, :name => 'table'},
      COLUMN_FAMILY => {:type => ::Thrift::Types::STRING, :name => 'column_family'},
      STARTWITH => {:type => ::Thrift::Types::STRING, :name => 'startWith', :default => %q""},
      STOPAT => {:type => ::Thrift::Types::STRING, :name => 'stopAt', :default => %q""},
      MAXRESULTS => {:type => ::Thrift::Types::I32, :name => 'maxResults', :default => 100}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class Get_key_range_result
    include ::Thrift::Struct
    SUCCESS = 0
    IRE = 1

    ::Thrift::Struct.field_accessor self, :success, :ire
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}},
      IRE => {:type => ::Thrift::Types::STRUCT, :name => 'ire', :class => InvalidRequestException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringProperty_args
    include ::Thrift::Struct
    PROPERTYNAME = 1

    ::Thrift::Struct.field_accessor self, :propertyName
    FIELDS = {
      PROPERTYNAME => {:type => ::Thrift::Types::STRING, :name => 'propertyName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringProperty_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRING, :name => 'success'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringListProperty_args
    include ::Thrift::Struct
    PROPERTYNAME = 1

    ::Thrift::Struct.field_accessor self, :propertyName
    FIELDS = {
      PROPERTYNAME => {:type => ::Thrift::Types::STRING, :name => 'propertyName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class GetStringListProperty_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING}}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class DescribeTable_args
    include ::Thrift::Struct
    TABLENAME = 1

    ::Thrift::Struct.field_accessor self, :tableName
    FIELDS = {
      TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class DescribeTable_result
    include ::Thrift::Struct
    SUCCESS = 0
    NFE = 1

    ::Thrift::Struct.field_accessor self, :success, :nfe
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRING}}},
      NFE => {:type => ::Thrift::Types::STRUCT, :name => 'nfe', :class => NotFoundException}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class ExecuteQuery_args
    include ::Thrift::Struct
    QUERY = 1

    ::Thrift::Struct.field_accessor self, :query
    FIELDS = {
      QUERY => {:type => ::Thrift::Types::STRING, :name => 'query'}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

  class ExecuteQuery_result
    include ::Thrift::Struct
    SUCCESS = 0

    ::Thrift::Struct.field_accessor self, :success
    FIELDS = {
      SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => CqlResult}
    }

    def struct_fields; FIELDS; end

    def validate
    end

  end

end

